<!doctype html>
<html lang="ja">
<head>
  <link rel="icon" href="/favicon.ico" type="image/x-icon" />
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="Content-Language" content="ja" />
  <title>サービスコントロール</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 760px; margin: 2rem auto; padding: 0 1rem; }
    h1 { font-size: 1.6rem; margin-bottom: 0.5rem; }
    p { color: #333; }
    #cards { display: flex; flex-direction: column; gap: 1.5rem; margin: 1rem 0; }
    .grid { display: grid; gap: 1rem; grid-template-columns: 1fr; }
    .card { border: 1px solid #ddd; border-radius: 8px; padding: 1rem; box-shadow: 0 2px 6px rgba(0,0,0,0.04); }
    .card h2 { margin: 0 0 0.5rem; font-size: 1.2rem; }
    .actions { margin: 0.5rem 0; }
    button { margin-right: 0.5rem; padding: 0.55rem 0.9rem; }
    .link {
      display: inline-block;
      margin-right: 0.5rem;
      padding: 0.55rem 0.9rem;
      background: #0f62fe;
      color: #fff;
      border: none;
      border-radius: 4px;
      text-decoration: none;
      font-weight: 600;
    }
    .status { font-weight: bold; margin-top: 0.5rem; }
    .health { font-size: 0.95rem; color: #444; margin-top: 0.35rem; line-height: 1.4; }
    .group { margin-bottom: 1.5rem; }
    .group-title { margin: 0 0 0.25rem; font-size: 1.1rem; color: #222; }
    .ops-status { display: inline-block; margin: 0.45rem 0 0; padding: 0.25rem 0.6rem; border-radius: 4px; font-weight: 600; font-size: 0.95rem; }
    .ops-status--active { background: #e6f4ea; color: #0f5132; }
    .ops-status--pending { background: #f5f5f5; color: #444; }
    .ops-status--error { background: #fbeaea; color: #842029; }
    .ops-status--starting { background: #fff4e5; color: #8a4b00; }
    .ops-status--stopped { background: #f5f5f5; color: #444; }
    .schedule { margin-top: 0.8rem; padding-top: 0.75rem; border-top: 1px dashed #ddd; display: flex; flex-direction: column; gap: 0.4rem; }
    .auto-toggle { display: flex; align-items: center; gap: 0.4rem; font-size: 0.95rem; font-weight: 600; }
    .schedule-inputs { display: flex; flex-wrap: wrap; gap: 0.4rem; align-items: center; font-size: 0.9rem; }
    .schedule-inputs label { display: flex; align-items: center; gap: 0.2rem; }
    .schedule-inputs input { padding: 0.25rem 0.35rem; font-size: 0.9rem; }
    .schedule-rows { display: flex; flex-direction: column; gap: 0.35rem; width: 100%; }
    .schedule-row { display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem; }
    .schedule-row strong { min-width: 4.5rem; display: inline-block; }
    .idle-field.hidden { display: none; }
    .schedule-status { font-size: 0.85rem; color: #444; }
    .auth-status { font-size: 0.95rem; color: #0f5132; background: #e4f0e5; padding: 0.5rem 0.75rem; border-radius: 6px; border: 1px solid #cfe3ce; margin-bottom: 1rem; }
    .timezone-note { font-size: 0.9rem; color: #555; margin-top: 0.25rem; }
    .schedule-hint { font-size: 0.8rem; color: #666; margin-top: 0.35rem; }
    .credential-card { border: 1px solid #ccc; border-radius: 8px; padding: 1rem; box-shadow: 0 1px 4px rgba(0,0,0,0.08); margin-bottom: 1rem; }
    .credential-card p { margin: 0.35rem 0; }
    .credential-card .credential-label { font-weight: 600; color: #222; }
    .credential-card.hidden { display: none; }
  </style>
</head>
<body>
  <h1>サービスコントロール</h1>
  <p>サービスコントロールAPIで各サービスの起動・停止・状態取得を確認できます。自動起動・停止がオンになっていると、その指定時間中はスケジュールされた起動・停止の制御が優先されるため、通常のアイドル検知による自動停止（アイドル機能）は動作しません。</p>
  <p class="timezone-note" id="jst-clock">現在時刻 (JST) を読み込み中...</p>

  <div id="auth-status" class="auth-status">認証なしで利用しています</div>
  <div id="login-container"></div>
  <div id="pgadmin-credentials" class="credential-card hidden">
    <h2>pgAdmin 用 DB 資格情報</h2>
    <p><span class="credential-label">ユーザー名:</span> <span data-pgadmin-credential="username">-</span></p>
    <p><span class="credential-label">パスワード:</span> <span data-pgadmin-credential="password">-</span></p>
  </div>

  <div class="grid" id="cards"></div>

  <script>
    const API_BASE = "${api_base_url}";
    const KEYCLOAK_CLIENT_ID = "${keycloak_client_id}";
    const KEYCLOAK_BASE_URL = "${keycloak_base_url}";
    const KEYCLOAK_REALM = "${keycloak_realm}";
    const API_BASE_CLEAN = API_BASE ? API_BASE.replace(/\/+$/, '') : '';
    const KEYCLOAK_BASE_CLEAN = KEYCLOAK_BASE_URL ? KEYCLOAK_BASE_URL.replace(/\/+$/, '') : '';
    const KEYCLOAK_REALM_CLEAN = KEYCLOAK_REALM ? KEYCLOAK_REALM.replace(/^\/+|\/+$/g, '') : '';
    const KEYCLOAK_TOKEN_ENDPOINT = KEYCLOAK_BASE_CLEAN && KEYCLOAK_REALM_CLEAN
      ? `$${KEYCLOAK_BASE_CLEAN}/realms/$${KEYCLOAK_REALM_CLEAN}/protocol/openid-connect/token`
      : '';
    const API_MAX_RETRY = 3;
    const API_RETRY_BASE_MS = 300;
    const TOKEN_REFRESH_MS = 5 * 60 * 1000;
    const services = [
      { key: 'keycloak', name: 'Keycloak', host: 'keycloak', path: '/admin/', desc: 'ID管理・認証／認可・情報セキュリティ' },
      { key: 'zulip', name: 'Zulip', host: 'zulip', desc: 'コミュニケーション、組織変革・関係性マネジメントのハブ' },
      { key: 'growi', name: 'GROWI', host: 'growi', desc: 'ナレッジ、戦略・ポリシー・手順の文書化' },
      { key: 'odoo', name: 'Odoo', host: 'odoo', desc: '財務・サプライヤ・CRM・ポートフォリオ／プロジェクト' },
      { key: 'orangehrm', name: 'OrangeHRM', host: 'orangehrm', desc: 'HR・組織・要員管理' },
      { key: 'cmdbuild-r2u', name: 'CMDBuild Ready2Use', host: 'cmdbuild', desc: 'ITSM の中核：サービス／CI／インシデント／要求／変更／SLA 等' },
      { key: 'n8n', name: 'n8n', host: 'n8n', desc: 'サービス管理プロセスにおける自動化・ツール連携ハブ' },
      { key: 'sulu', name: 'Sulu', host: 'sulu', desc: 'メインサービスのダミー' },
      { key: 'exastro-web', name: 'Exastro ITA Web', host: 'ita-web', desc: '構成・IaC・ジョブ実行 (Web)' },
      { key: 'exastro-api', name: 'Exastro ITA API', host: 'ita-api', desc: '構成・IaC・ジョブ実行 (API)' },
      { key: 'gitlab', name: 'GitLab', host: 'gitlab', desc: '開発・DevOps・Issue・CI/CD' },
      { key: 'pgadmin', name: 'pgAdmin', host: 'pgadmin', desc: 'DB プラットフォーム管理' },
      { key: 'phpmyadmin', name: 'phpMyAdmin', host: 'phpmyadmin', desc: 'MySQL/MariaDB 管理' },
    ];
    const serviceAutoStopCapabilities = ${service_control_autostop_flags};
    const apiEnabledServices = new Set(${service_control_enabled_svcs});
    const lockedScheduleServices = new Set(['keycloak', 'n8n', 'zulip']);
    const UI_LOCALE = 'ja-JP';
    const UI_TIMEZONE = 'Asia/Tokyo';
    const timezoneFormatter = new Intl.DateTimeFormat(UI_LOCALE, {
      dateStyle: 'long',
      timeStyle: 'medium',
      timeZone: UI_TIMEZONE,
    });
    const MINUTES_PER_DAY = 24 * 60;

    function parseTimeValue(value) {
      if (typeof value !== 'string') return null;
      const parts = value.split(':');
      if (parts.length !== 2) return null;
      const hours = Number(parts[0]);
      const minutes = Number(parts[1]);
      if (Number.isNaN(hours) || Number.isNaN(minutes)) return null;
      return hours * 60 + minutes;
    }

    function formatTimeValue(minutes) {
      if (typeof minutes !== 'number' || Number.isNaN(minutes)) return '';
      const normalized = ((Math.round(minutes) % MINUTES_PER_DAY) + MINUTES_PER_DAY) % MINUTES_PER_DAY;
      const hours = Math.floor(normalized / 60);
      const mins = normalized % 60;
      const hoursStr = hours.toString().padStart(2, '0');
      const minsStr = mins.toString().padStart(2, '0');
      return hoursStr + ':' + minsStr;
    }

    function normalizeTime(value) {
      const minutes = parseTimeValue(value);
      return minutes === null ? '' : formatTimeValue(minutes);
    }

    const DEFAULT_WEEKDAY_START_JST = '17:00';
    const DEFAULT_WEEKDAY_STOP_JST = '22:00';
    const DEFAULT_HOLIDAY_START_JST = '08:00';
    const DEFAULT_HOLIDAY_STOP_JST = '23:00';
    const DEFAULT_IDLE_MINUTES = 60;
    const jstClockEl = document.getElementById('jst-clock');
    function updateJstClock() {
      if (!jstClockEl) return;
      jstClockEl.textContent = `現在時刻 (JST): $${timezoneFormatter.format(new Date())}`;
    }
    if (jstClockEl) {
      updateJstClock();
      setInterval(updateJstClock, 1000);
    }
    const servicesWithStatus = services.map(s => {
      const apiEnabled = apiEnabledServices.has(s.key);
      return {
        ...s,
        apiEnabled,
        autostopSupported: Boolean(serviceAutoStopCapabilities[s.key]),
      };
    });
    const serviceMap = Object.fromEntries(servicesWithStatus.map(s => [s.key, s]));
    const apiEnabledList = servicesWithStatus.filter(s => s.apiEnabled);
    const groups = [
      { title: 'General Management（一般管理）', items: ['keycloak', 'zulip', 'growi', 'odoo', 'orangehrm'] },
      { title: 'Service Management（サービス管理）', items: ['cmdbuild-r2u', 'n8n', 'sulu'] },
      { title: 'Technical Management（技術管理）', items: ['exastro-web', 'exastro-api', 'gitlab', 'pgadmin', 'phpmyadmin'] },
    ];
    const cardsEl = document.getElementById('cards');
    const pgadminCredentialCard = document.getElementById('pgadmin-credentials');
    const pgadminCredentialUsernameEl = pgadminCredentialCard ? pgadminCredentialCard.querySelector('[data-pgadmin-credential="username"]') : null;
    const pgadminCredentialPasswordEl = pgadminCredentialCard ? pgadminCredentialCard.querySelector('[data-pgadmin-credential="password"]') : null;
    const scheduleState = new Map();
    const rootDomain = (() => {
      const host = window.location.hostname;
      const parts = host.split('.');
      if (parts.length >= 3) return parts.slice(1).join('.');
      return host;
    })();
    const authStatusEl = document.getElementById('auth-status');
    const loginContainer = document.getElementById('login-container');
    let accessToken = null;
    let refreshToken = null;
    let tokenExpiresAt = 0;

    function setAuthMessage(message) {
      if (authStatusEl) {
        authStatusEl.textContent = message;
      }
    }

    function persistTokens() {
      if (accessToken) {
        const payload = { accessToken, refreshToken, tokenExpiresAt };
        sessionStorage.setItem('service_control_tokens', JSON.stringify(payload));
      } else {
        sessionStorage.removeItem('service_control_tokens');
      }
    }

    function restoreTokens() {
      try {
        const raw = sessionStorage.getItem('service_control_tokens');
        if (!raw) return;
        const parsed = JSON.parse(raw);
        accessToken = parsed.accessToken || null;
        refreshToken = parsed.refreshToken || null;
        tokenExpiresAt = parsed.tokenExpiresAt || 0;
      } catch {
        accessToken = null;
        refreshToken = null;
        tokenExpiresAt = 0;
      }
    }

    function clearTokens() {
      accessToken = null;
      refreshToken = null;
      tokenExpiresAt = 0;
      persistTokens();
    }

    function removeLogoutButton() {
      const btn = document.getElementById('logout-btn');
      if (btn) btn.remove();
    }

    function forceLogin(message = 'ログインしてください') {
      clearTokens();
      removeLogoutButton();
      setAuthMessage(message);
      renderLoginForm(message);
    }

    async function requestToken(payload) {
      if (!KEYCLOAK_TOKEN_ENDPOINT) {
        throw new Error('Keycloak のトークンエンドポイントが構成されていません。');
      }
      const params = new URLSearchParams();
      params.append('client_id', KEYCLOAK_CLIENT_ID);
      Object.entries(payload).forEach(([key, value]) => {
        if (value !== undefined && value !== null) {
          params.append(key, String(value));
        }
      });
      const res = await fetch(KEYCLOAK_TOKEN_ENDPOINT, {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: params,
      });
      const data = await res.json().catch(() => ({}));
      if (!res.ok) {
        const message = data.error_description || data.error || data.message || res.statusText;
        throw new Error(message || 'トークンの取得に失敗しました');
      }
      return data;
    }

    async function refreshAccessTokenIfNeeded() {
      if (!accessToken) return;
      const now = Date.now();
      if (tokenExpiresAt && tokenExpiresAt - now > 60 * 1000) {
        return;
      }
      if (!refreshToken) return;
      let data;
      try {
        data = await requestToken({
          grant_type: 'refresh_token',
          refresh_token: refreshToken,
        });
      } catch {
        forceLogin('トークンの更新に失敗しました。再ログインしてください。');
        throw new Error('トークンの更新に失敗しました。再ログインしてください。');
      }
      accessToken = data.access_token || null;
      refreshToken = data.refresh_token || null;
      const expiresIn = data.expires_in || 0;
      tokenExpiresAt = Date.now() + expiresIn * 1000;
      persistTokens();
    }

    async function performLogin(username, password) {
      let data;
      try {
        data = await requestToken({
          grant_type: 'password',
          username,
          password,
        });
      } catch (err) {
        throw new Error(err?.message || '認証に失敗しました');
      }
      accessToken = data.access_token || null;
      refreshToken = data.refresh_token || null;
      const expiresIn = data.expires_in || 0;
      tokenExpiresAt = Date.now() + expiresIn * 1000;
      persistTokens();
    }

    function renderLoginForm(message = '') {
      cardsEl.innerHTML = '';
      const note = message ? `<div style="color:#b00020; margin-bottom:0.5rem;">$${message}</div>` : '';
      loginContainer.innerHTML = `
        <div class="card">
          <h2>ログイン</h2>
          $${note}
          <form id="login-form">
            <div style="margin-bottom:0.5rem;">
              <label>ユーザー名<br><input type="text" name="username" required style="width:100%; padding:0.4rem;"></label>
            </div>
            <div style="margin-bottom:0.5rem;">
              <label>パスワード<br><input type="password" name="password" required style="width:100%; padding:0.4rem;"></label>
            </div>
            <button type="submit">ログイン</button>
          </form>
        </div>
      `;
      const form = document.getElementById('login-form');
      form.addEventListener('submit', async (ev) => {
        ev.preventDefault();
        const formData = new FormData(form);
        const username = (formData.get('username') || '').toString();
        const password = (formData.get('password') || '').toString();
        setAuthMessage('ログイン処理中...');
        try {
          await performLogin(username, password);
          setAuthMessage(`ログイン済み: $${username}`);
          loginContainer.innerHTML = '';
          renderCards();
          bindEvents();
          apiEnabledList.forEach(s => updateStatus(s.key));
          apiEnabledList.forEach(s => fetchSchedule(s.key));
          scheduleTokenRefresh();
        } catch (e) {
          clearTokens();
          setAuthMessage('ログインに失敗しました');
          renderLoginForm(e?.message);
        }
      });
    }

    function renderLogoutButton() {
      const btnId = 'logout-btn';
      let btn = document.getElementById(btnId);
      if (!btn) {
        btn = document.createElement('button');
        btn.id = btnId;
        btn.style.marginLeft = '0.5rem';
        authStatusEl.after(btn);
      }
      btn.textContent = 'ログアウト';
      btn.onclick = () => {
        clearTokens();
        setAuthMessage('ログアウトしました');
        btn.remove();
        renderLoginForm();
      };
    }

    function scheduleTokenRefresh() {
      setInterval(() => {
        refreshAccessTokenIfNeeded().catch((err) => {
          console.warn(err.message);
        });
      }, TOKEN_REFRESH_MS);
    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function retryDelay(attempt) {
      const jitter = Math.random() * 100;
      return API_RETRY_BASE_MS * Math.pow(2, attempt) + jitter;
    }

    function isRetryableStatus(status) {
      return status >= 500 || status === 429;
    }

    function log(msg) {
      console.log(msg);
    }

    async function callApi(service, path, method = 'GET', payload = null) {
      if (!API_BASE) {
        log('API のベース URL が設定されていません。');
        throw new Error('API のベース URL が設定されていません。');
      }
      if (!accessToken) {
        forceLogin('ログインしてください');
        throw new Error('ログインしてください');
      }
      try {
        await refreshAccessTokenIfNeeded();
      } catch (err) {
        log(`エラー: $${err.message}`);
        throw err;
      }
      const base = API_BASE_CLEAN || API_BASE;
      const url = `$${base}$${path}?service=$${encodeURIComponent(service)}`;
      const headers = payload !== null ? { 'Content-Type': 'application/json' } : {};
      headers.Authorization = `Bearer $${accessToken}`;
      const options = { method };
      if (Object.keys(headers).length > 0) {
        options.headers = headers;
      }
      if (payload !== null) {
        options.body = JSON.stringify(payload);
      }
      let lastError = null;
      for (let attempt = 0; attempt < API_MAX_RETRY; attempt += 1) {
        try {
          const res = await fetch(url, options);
          const body = await res.json().catch(() => ({}));
          if (res.status === 401 || res.status === 403) {
            forceLogin(body.message || '認証が無効になりました。再ログインしてください。');
            const err = new Error(body.message || res.statusText);
            err.retryable = false;
            throw err;
          }
          if (!res.ok) {
            if (isRetryableStatus(res.status) && attempt < API_MAX_RETRY - 1) {
              await sleep(retryDelay(attempt));
              continue;
            }
            const err = new Error(body.message || res.statusText);
            err.retryable = false;
            throw err;
          }
          return body;
        } catch (err) {
          lastError = err;
          const shouldRetry = (err?.retryable ?? true) && attempt < API_MAX_RETRY - 1;
          if (shouldRetry) {
            await sleep(retryDelay(attempt));
            continue;
          }
        }
      }
      if (lastError?.message && lastError.message.includes('ログイン')) {
        forceLogin(lastError.message);
      }
      log(`エラー: $${lastError?.message || 'unknown error'}`);
      throw lastError || new Error('unknown error');
    }

    function renderHealth(service, data) {
      const el = document.querySelector(`[data-health="$${service}"]`);
      if (!el) return;
      if (!data || !data.targetGroupHealth) {
        el.textContent = 'TG: 情報なし';
        return;
      }
      const sum = data.targetGroupHealth.summary || {};
      el.textContent = `TG: healthy=$${sum.healthy || 0}, unhealthy=$${sum.unhealthy || 0}, total=$${sum.total || 0}`;
    }

    function updateOpsStatusUI(service, label, variant = 'pending') {
      if (!cardsEl) return;
      const el = cardsEl.querySelector('[data-ops-status="' + service + '"]');
      if (!el) return;
      const normalizedVariant = variant || 'pending';
      el.textContent = '運用ステータス：' + label;
      el.className = 'ops-status ops-status--' + normalizedVariant;
    }

    function deriveOpsStatus(summary) {
      if (!summary) return { label: '状態不明', variant: 'pending' };
      const healthy = Number(summary.healthy) || 0;
      const unhealthy = Number(summary.unhealthy) || 0;
      const total = Number(summary.total) || 0;
      if (healthy >= 1) {
        return { label: '稼働中', variant: 'active' };
      }
      if (unhealthy >= 1) {
        return { label: 'エラー', variant: 'error' };
      }
      if (total >= 1 && healthy === 0) {
        return { label: '起動中', variant: 'starting' };
      }
      return { label: '停止中', variant: 'stopped' };
    }

    function applyOpsStatus(service, summary) {
      const derived = deriveOpsStatus(summary);
      updateOpsStatusUI(service, derived.label, derived.variant);
    }

    function applyScheduleToUI(service, schedule) {
      const checkbox = cardsEl.querySelector('[data-action="toggle-auto"][data-service="' + service + '"]');
      const weekdayStartInput = cardsEl.querySelector('[data-action="set-weekday-start"][data-service="' + service + '"]');
      const weekdayStopInput = cardsEl.querySelector('[data-action="set-weekday-stop"][data-service="' + service + '"]');
      const holidayStartInput = cardsEl.querySelector('[data-action="set-holiday-start"][data-service="' + service + '"]');
      const holidayStopInput = cardsEl.querySelector('[data-action="set-holiday-stop"][data-service="' + service + '"]');
      const idleInput = cardsEl.querySelector('[data-action="set-idle"][data-service="' + service + '"]');
      const statusEl = cardsEl.querySelector('[data-schedule-status="' + service + '"]');
      const enabled = Boolean(schedule && schedule.enabled);
      const locked = lockedScheduleServices.has(service);
      const baseStart = normalizeTime((schedule && schedule.start_time) || DEFAULT_WEEKDAY_START_JST) || DEFAULT_WEEKDAY_START_JST;
      const baseStop = normalizeTime((schedule && schedule.stop_time) || DEFAULT_WEEKDAY_STOP_JST) || DEFAULT_WEEKDAY_STOP_JST;
      const weekdayStart = normalizeTime((schedule && (schedule.weekday_start_time || schedule.start_time)) || DEFAULT_WEEKDAY_START_JST) || DEFAULT_WEEKDAY_START_JST;
      const weekdayStop = normalizeTime((schedule && (schedule.weekday_stop_time || schedule.stop_time)) || DEFAULT_WEEKDAY_STOP_JST) || DEFAULT_WEEKDAY_STOP_JST;
      const holidayStart = normalizeTime((schedule && (schedule.holiday_start_time || schedule.start_time)) || DEFAULT_HOLIDAY_START_JST) || DEFAULT_HOLIDAY_START_JST;
      const holidayStop = normalizeTime((schedule && (schedule.holiday_stop_time || schedule.stop_time)) || DEFAULT_HOLIDAY_STOP_JST) || DEFAULT_HOLIDAY_STOP_JST;
      const idleValue = (schedule && schedule.idle_minutes) || DEFAULT_IDLE_MINUTES;
      if (checkbox) {
        checkbox.checked = Boolean(enabled);
        checkbox.disabled = locked;
      }
      if (weekdayStartInput) {
        weekdayStartInput.value = weekdayStart;
        weekdayStartInput.disabled = locked;
      }
      if (weekdayStopInput) {
        weekdayStopInput.value = weekdayStop;
        weekdayStopInput.disabled = locked;
      }
      if (holidayStartInput) {
        holidayStartInput.value = holidayStart;
        holidayStartInput.disabled = locked;
      }
      if (holidayStopInput) {
        holidayStopInput.value = holidayStop;
        holidayStopInput.disabled = locked;
      }
      if (idleInput) {
        idleInput.value = idleValue;
        const idleSupported = Boolean(serviceAutoStopCapabilities[service]);
        idleInput.disabled = locked || !idleSupported;
      }
      updateIdleField(service);
      if (statusEl) {
        if (locked) {
          statusEl.textContent = `自動スケジュールは固定（変更不可）。現在: $${enabled ? "オン" : "オフ"} / 平日 $${weekdayStart}→$${weekdayStop} / 土日祝 $${holidayStart}→$${holidayStop}`;
        } else {
          statusEl.textContent = enabled
            ? `自動 (JST): 平日 $${weekdayStart}→$${weekdayStop} / 土日祝 $${holidayStart}→$${holidayStop} (アイドル $${idleValue}分)`
            : '自動起動/停止はオフ';
        }
      }
      scheduleState.set(service, {
        ...schedule,
        start_time: baseStart,
        stop_time: baseStop,
        weekday_start_time: weekdayStart,
        weekday_stop_time: weekdayStop,
        holiday_start_time: holidayStart,
        holiday_stop_time: holidayStop,
      });
    }

    async function fetchSchedule(service) {
      try {
        const schedule = await callApi(service, '/schedule', 'GET');
        applyScheduleToUI(service, schedule);
      } catch {
        const statusEl = cardsEl.querySelector('[data-schedule-status="' + service + '"]');
        if (statusEl) statusEl.textContent = 'スケジュール情報を取得できません';
      }
    }

    async function sendScheduleUpdate(service, payload) {
      try {
        const updated = await callApi(service, '/schedule', 'POST', payload);
        applyScheduleToUI(service, updated);
      } catch {
        const statusEl = cardsEl.querySelector('[data-schedule-status="' + service + '"]');
        if (statusEl) statusEl.textContent = 'スケジュール更新に失敗';
      }
    }

    async function updateStatus(service) {
      const statusEl = document.querySelector(`[data-status="$${service}"]`);
      statusEl.textContent = '状態: 取得中...';
      try {
        const data = await callApi(service, '/status', 'GET');
        statusEl.textContent = `状態: desired=$${data.desiredCount}, running=$${data.runningCount}`;
        log(`[$${service}] 状態取得に成功: $${JSON.stringify(data)}`);
        renderHealth(service, data);
        applyOpsStatus(service, data?.targetGroupHealth?.summary);
      } catch (_) {
        statusEl.textContent = '状態: エラー';
        renderHealth(service, null);
        updateOpsStatusUI(service, '取得エラー', 'error');
      }
    }

    async function startSvc(service) {
      const statusEl = document.querySelector(`[data-status="$${service}"]`);
      statusEl.textContent = '起動中...';
      await callApi(service, '/start', 'POST');
      log(`[$${service}] 起動をリクエストしました`);
      updateStatus(service);
    }

    async function stopSvc(service) {
      const statusEl = document.querySelector(`[data-status="$${service}"]`);
      statusEl.textContent = '停止中...';
      await callApi(service, '/stop', 'POST');
      log(`[$${service}] 停止をリクエストしました`);
      updateStatus(service);
    }

    function renderCards() {
      cardsEl.innerHTML = groups.map(g => `
        <div class="group">
          <h2 class="group-title">$${g.title}</h2>
          <div class="grid">
            $${g.items.map(key => {
              const s = serviceMap[key];
              if (!s) return '';
              const initialOpsStatus = s.apiEnabled ? '確認中' : '未実装';
              const initialOpsVariant = 'pending';
              return `
        <div class="card">
                  <h2>$${s.name}</h2>
                  <div class="ops-status ops-status--$${initialOpsVariant}" data-ops-status="$${s.key}">運用ステータス：$${initialOpsStatus}</div>
                  <div class="health">$${s.desc || ''}</div>
                  <div class="actions">
                    <a class="link" href="https://$${s.host}.$${rootDomain}$${s.path || ''}" target="_blank" rel="noopener noreferrer">開く</a>
                    <button data-action="start" data-service="$${s.key}">起動</button>
                    <button data-action="stop" data-service="$${s.key}">停止</button>
                    <button data-action="status" data-service="$${s.key}">状態取得</button>
                  </div>
                  <div class="status" data-status="$${s.key}">状態: -</div>
                  <div class="schedule">
                    <label class="auto-toggle">
                      <input type="checkbox" data-action="toggle-auto" data-service="$${s.key}">
                      自動起動・停止
                    </label>
                    <div class="schedule-inputs">
                      <div class="schedule-rows">
                        <div class="schedule-row">
                          <strong>平日</strong>
                          <label>起動
                            <input type="time" data-action="set-weekday-start" data-service="$${s.key}" value="${DEFAULT_WEEKDAY_START_JST}">
                          </label>
                          <label>停止
                            <input type="time" data-action="set-weekday-stop" data-service="$${s.key}" value="${DEFAULT_WEEKDAY_STOP_JST}">
                          </label>
                        </div>
                        <div class="schedule-row">
                          <strong>土日祝</strong>
                          <label>起動
                            <input type="time" data-action="set-holiday-start" data-service="$${s.key}" value="${DEFAULT_HOLIDAY_START_JST}">
                          </label>
                          <label>停止
                            <input type="time" data-action="set-holiday-stop" data-service="$${s.key}" value="${DEFAULT_HOLIDAY_STOP_JST}">
                          </label>
                        </div>
                      </div>
                      <label class="idle-field">アイドル
                        <input type="number" min="1" data-action="set-idle" data-service="$${s.key}" value="${DEFAULT_IDLE_MINUTES}">分
                      </label>
                    </div>
                    <div class="schedule-status" data-schedule-status="$${s.key}">スケジュール情報を読み込み中...</div>
                  </div>
                  <div class="health" data-health="$${s.key}">TG: -</div>
                  </div>
                `;
              }).join('')}
            </div>
          </div>
        `).join('');
        servicesWithStatus.forEach(s => {
          updateIdleField(s.key);
          if (!s.apiEnabled) {
            markServiceApiUnavailable(s.key);
          }
        });
        loadPgadminCredentials();
      }

    function updateIdleField(service) {
      const idleInput = cardsEl.querySelector(`[data-action="set-idle"][data-service="$${service}"]`);
      if (!idleInput) return;
      const idleLabel = idleInput.closest('label');
      const idleSupported = Boolean(serviceAutoStopCapabilities[service]);
      idleInput.disabled = !idleSupported;
      if (idleLabel) {
        idleLabel.classList.toggle('hidden', !idleSupported);
      }
    }

    function markServiceApiUnavailable(service) {
      cardsEl.querySelectorAll(`[data-service="$${service}"]`).forEach(el => {
        if (el instanceof HTMLButtonElement || el instanceof HTMLInputElement) {
          el.disabled = true;
        }
      });
      const statusEl = cardsEl.querySelector(`[data-status="$${service}"]`);
      if (statusEl) statusEl.textContent = '状態: API 未対応';
      const scheduleEl = cardsEl.querySelector(`[data-schedule-status="$${service}"]`);
      if (scheduleEl) scheduleEl.textContent = 'スケジュール: API 未対応';
      const healthEl = cardsEl.querySelector(`[data-health="$${service}"]`);
      if (healthEl) healthEl.textContent = 'TG: API 未対応';
      updateOpsStatusUI(service, '未実装', 'pending');
    }

    function bindEvents() {
      cardsEl.addEventListener('click', (ev) => {
        if (!(ev.target instanceof HTMLButtonElement)) return;
        const action = ev.target.dataset.action;
        const service = ev.target.dataset.service;
        if (!action || !service) return;
        if (!apiEnabledServices.has(service)) return;
        if (action === 'start') startSvc(service);
        if (action === 'stop') stopSvc(service);
        if (action === 'status') updateStatus(service);
      });
      cardsEl.addEventListener('change', (ev) => {
        if (!(ev.target instanceof HTMLInputElement)) return;
        const action = ev.target.dataset.action;
        const service = ev.target.dataset.service;
        if (!action || !service) return;
        if (!apiEnabledServices.has(service)) return;
        if (lockedScheduleServices.has(service)) return;
        if (action === 'toggle-auto') {
          sendScheduleUpdate(service, { enabled: ev.target.checked });
          return;
        }
        if (action === 'set-idle') {
          if (!serviceAutoStopCapabilities[service]) return;
          if (ev.target.value === '') return;
          sendScheduleUpdate(service, { idle_minutes: Number(ev.target.value) });
          return;
        }
        const converted = ev.target.value ? normalizeTime(ev.target.value) : '';
        if (!converted) return;
        if (action === 'set-weekday-start') {
          sendScheduleUpdate(service, { weekday_start_time: converted });
        } else if (action === 'set-weekday-stop') {
          sendScheduleUpdate(service, { weekday_stop_time: converted });
        } else if (action === 'set-holiday-start') {
          sendScheduleUpdate(service, { holiday_start_time: converted });
        } else if (action === 'set-holiday-stop') {
          sendScheduleUpdate(service, { holiday_stop_time: converted });
        }
      });
    }

    async function refreshServiceData() {
      // Lambda のスロット枯渇を防ぐためシリアルに呼び出す
      for (const svc of apiEnabledList) {
        if (!svc.apiEnabled) continue;
        try {
          await updateStatus(svc.key);
          await fetchSchedule(svc.key);
        } catch (err) {
          const msg = (err && err.message) ? err.message : err;
          log(`サービス $${svc.key} の更新に失敗: $${msg}`);
        }
      }
      loadPgadminCredentials();
    }

    function setPgadminCredentialVisibility(visible) {
      if (!pgadminCredentialCard) return;
      pgadminCredentialCard.classList.toggle('hidden', !visible);
    }

    function setPgadminCredentialValues(username, password) {
      if (pgadminCredentialUsernameEl) {
        pgadminCredentialUsernameEl.textContent = username || '非公開';
      }
      if (pgadminCredentialPasswordEl) {
        pgadminCredentialPasswordEl.textContent = password || '非公開';
      }
    }

    async function loadPgadminCredentials() {
      if (!pgadminCredentialCard || !apiEnabledServices.has('pgadmin') || !API_BASE) {
        setPgadminCredentialVisibility(false);
        return;
      }
      try {
        const data = await callApi('pgadmin', '/db-credentials', 'GET');
        if (data && (data.username || data.password)) {
          setPgadminCredentialValues(data.username, data.password);
          setPgadminCredentialVisibility(true);
        } else {
          setPgadminCredentialVisibility(false);
        }
      } catch (err) {
        console.warn('pgAdmin credentials fetch failed', err);
        setPgadminCredentialVisibility(false);
      }
    }
    if (!API_BASE) {
      renderCards();
      Array.from(cardsEl.querySelectorAll('button')).forEach(btn => btn.disabled = true);
      Array.from(cardsEl.querySelectorAll('[data-action="toggle-auto"], [data-action="set-start"], [data-action="set-stop"], [data-action="set-idle"]')).forEach(el => el.disabled = true);
      Array.from(cardsEl.querySelectorAll('[data-schedule-status]')).forEach(el => el.textContent = 'スケジュール: API が未設定です');
      Array.from(cardsEl.querySelectorAll('.status')).forEach(el => el.textContent = '状態: API が未設定です');
      setAuthMessage('サービスコントロール API が未設定です');
      log('Terraform の service_control_api_base_url を設定するとコントロール API が有効になります。');
    } else {
      restoreTokens();
      if (accessToken) {
        setAuthMessage('ログイン済み');
        renderLogoutButton();
        renderCards();
        bindEvents();
        refreshServiceData();
        scheduleTokenRefresh();
      } else {
        setAuthMessage('ログインしてください');
        renderLoginForm();
      }
    }
  </script>
</body>
</html>
